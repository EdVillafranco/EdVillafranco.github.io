Los errores incluyen errores en el código, requisitos faltantes, fallas técnicas y más. Las pruebas de software también pueden determinar si el resultado al utilizar la aplicación difiere de las expectativas.

Si bien lo ideal es que las pruebas se realicen en cada etapa del desarrollo, en última instancia, las pruebas son el paso final antes de que la aplicación se lance a producción. Es importante que los probadores de software utilicen pruebas tanto manuales como automatizadas para garantizar que el producto final sea el mejor posible.
							
Cuando se trata de pruebas de software, existen tres tipos de personas que se centrarán principalmente en las pruebas dentro de una organización:

Business tester. While these testers are stakeholders in the business team, they often have fewer technical skills. Therefore, business testers often implement manual and exploratory testing, or codeless testing as they make the switch to automation.

SDET (Software Developer in Testing). This type of tester has significant testing experience and coding knowledge, which means they are almost always accountable for code-based testing. 

Software developer. While developers also work with code-based testing, developers usually focus more on creating earlier-stage unit and acceptance tests.  
Read on to learn more about the specific types of software testing and how to go about properly testing your product.

This is just a sample of different methods of testing, but there are many others. Many of these types of testing can be done manually — or they can be automated.

///////////////////////////

1. Accessibility Testing 
Accessibility testing is the practice of ensuring your mobile and web apps are working and usable for users without and with disabilities such as vision impairment, hearing disabilities, and other physical or cognitive conditions. 

2. Acceptance Testing 
Acceptance testing ensures that the end-user (customers) can achieve the goals set in the business requirements, which determines whether the software is acceptable for delivery or not. It is also known as user acceptance testing (UAT).  

3. Black Box Testing 
Black box testing involves testing against a system where the code and paths are invisible. 

4. End to End Testing 
End to end testing is a technique that tests the application’s workflow from beginning to end to make sure everything functions as expected. 

5. Functional Testing 
Functional testing checks an application, website, or system to ensure it’s doing exactly what it’s supposed to be doing. 

6. Interactive Testing 
Also known as manual testing, interactive testing enables testers to create and facilitate manual tests for those who do not use automation and collect results from external tests.  

7. Integration Testing 
Integration testing ensures that an entire, integrated system meets a set of requirements. It is performed in an integrated hardware and software environment to ensure that the entire system functions properly.  

8. Load Testing 
This type of non-functional software testing process determines how the software application behaves while being accessed by multiple users simultaneously. 

9. Non Functional Testing 
Non functional testing verifies the readiness of a system according to nonfunctional parameters (performance, accessibility, UX, etc.)  which are never addressed by functional testing. 

10. Performance Testing 
Performance testing examines the speed, stability, reliability, scalability, and resource usage of a software application under a specified workload. 

11. Regression Testing 
Software regression testing is performed to determine if code modifications break an application or consume resources. 

12. Sanity Testing 
Performed after bug fixes, sanity testing determines that the bugs are fixed and that no further issues are introduced to these changes.  

13. Security Testing 
Security testing unveils the vulnerabilities of the system to ensure that the software system and application are free from any threats or risks. These tests aim to find any potential flaws and weaknesses in the software system that could lead to a loss of data, revenue, or reputation per employees or outsides of a company. 

14. Single User Performance Testing 
Single user performance testing checks that the application under test performs fine according to specified threshold without any system load. This benchmark can be then used to define a realistic threshold when the system is under load.  

15. Smoke Testing 
This type of software testing validates the stability of a software application, it is performed on the initial software build to ensure that the critical functions of the program are working. 

16. Stress Testing 
Stress testing is a software testing activity that tests beyond normal operational capacity to test the results. 

17. Unit Testing 
Unit testing is the process of checking small pieces of code to ensure that the individual parts of a program work properly on their own, speeding up testing strategies and reducing wasted tests. 

18. White Box Testing 
White box testing involves testing the product's underlying structure, architecture, and code to validate input-output flow and enhance design, usability, and security. 


///////////////////////////
Manual vs. Automated vs. Continuous Testing
There are three main ways you can do testing: manual, automated, and continuous. Let us take a closer look at each option. 

Manual testing is the most hands-on type of testing and is employed by every team at some point. Of course, in today’s fast-paced software development lifecycle, manual testing is tough to scale.

Automated testing uses test scripts and specialized tools to automate the process of software testing.

Continuous testing goes even further, applying the principles of automated testing in a scaled, continuous manner to achieve the most reliable test coverage for an enterprise. Keep reading to learn more about the differences between automated testing vs. manual testing and how continuous testing fits in.

///////////////////////////

Types of Manual Testing
While automated testing is certainly critical to delivering high-quality applications faster and at lower costs, manual testing still plays a very important role in the overall software testing process.

There are two main types of manual testing: 

1. White Box Testing 
White box testing involves testing the product's underlying structure, architecture, and code to validate input-output flow and enhance design, usability, and security. 

2. Black Box Testing 
Black box testing involves testing against a system where the code and paths are invisible. 

To make the most use of manual testing, it is important to test manually in areas that really need it. For example, you cannot automate matters of opinion. No matter which tool you use, it is next to impossible to determine how users feel about your software and user behavior.

Therefore, manual testing is still viewed as highly necessary in areas like usability testing, beta testing, A/B testing, and so on.

///////////////////////////

Types of Automation Testing
There are several test automation types — as well as frameworks and tools to support them.

The most popular types of tests that you should automate without a doubt include:

Unit testing.
Integration testing.
Smoke testing.
The reason why these tests should be automated is the fact that they all occur early in the software development lifecycle (SDLC). By running these automated tests early on, teams can receive faster feedback and resolve issues more quickly. 

With this shift-left test automation strategy, you can quickly scale your tests and boost coverage to accelerate delivery. Accelerated delivery through testing at scale will ultimately save an organization money, resources, and time while providing a better overall user experience. 

Other factors to consider when choosing which tests to automate include:

High volume and repeatability. Test automation is best for time-consuming test scripts that teams must run repeatedly.
Determinant outcomes. The results should have relatively predictable outcomes that a test script is fully capable of catching.
Business-critical tests. Test automation is also helpful for scenarios that may cause an interruption in service or damage one’s business.
If you are considering test automation, the following blog will take a more in-depth look at why test automation is important, as well as which tests you should automate, and how automated testing should work.

///////////////////////////

Example: Continuous Testing
Continuous testing is the process of reviewing and addressing software issues and risks at every stage of the development cycle.

The goal of continuous testing is to test early and often to minimize business risk and maximize the quality of application released to end users.

There are several steps to achieving continuous testing including:

Stable automation.
Full coverage.
Scalability.
Learn more about the path to continuous testing.


https://www.perfecto.io/resources/types-of-testing